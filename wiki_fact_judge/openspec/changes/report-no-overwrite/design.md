## Context

当前报告生成逻辑存在问题：运行测试计划或案例时，如果使用相同的报告名称，新报告会覆盖旧报告的数据。这是因为：
1. 报告名称可能基于案例/计划 ID 生成，缺乏唯一性
2. 创建报告时没有检查是否已存在同名报告
3. 数据库层面没有唯一性约束防止覆盖

用户需要保留每次运行的历史记录，用于：
- 对比不同时间的评估结果
- 追踪模型改进效果
- 审计和回溯历史数据

## Goals / Non-Goals

**Goals:**
- 确保每次运行测试都生成新的独立报告记录
- 使用唯一标识符区分同一案例/计划的不同运行
- 保持数据库结构不变
- 保持 API 接口向后兼容

**Non-Goals:**
- 不实现报告版本管理系统
- 不实现报告合并或对比功能
- 不修改现有报告的删除逻辑
- 不实现报告归档机制

## Decisions

### 1. 报告命名策略
**决策**: 使用 `时间戳 + 随机数 + 案例/计划标识` 组合生成唯一报告名称

**格式**: `report_{case_id}_{timestamp}_{random}` 或 `report_{plan_id}_{timestamp}_{random}`

**理由**:
- 时间戳确保不同时间运行的报告名称不同
- 随机数防止同一秒内多次运行的冲突
- 保留案例/计划标识便于关联查询

**备选方案**:
- 使用 UUID - 过于冗长，不利于人工识别
- 使用自增序号 - 需要查询最大序号，增加数据库压力
- 仅使用时间戳 - 精度不够时可能冲突

### 2. 报告创建时机
**决策**: 在 `report_service.create_report()` 中自动生成唯一名称，不依赖调用方传入

**理由**:
- 集中管理命名逻辑，避免多处实现不一致
- 调用方（pipeline_service）无需关心命名细节
- 便于后续修改命名策略

### 3. 数据库约束
**决策**: 不在数据库层面添加唯一约束，仅在应用层保证唯一性

**理由**:
- 应用层控制更灵活，可以生成友好名称
- 避免数据库错误影响用户体验
- 保持向后兼容，不破坏现有数据

### 4. 历史报告清理
**决策**: 不自动清理历史报告，由用户手动删除

**理由**:
- 历史数据可能有审计价值
- 自动清理策略难以满足所有用户需求
- 未来可实现可配置的清理策略

## Risks / Trade-offs

| Risk | Mitigation |
|------|------------|
| 报告数量快速增长，数据库膨胀 | 建议用户定期清理旧报告；未来可实现自动归档 |
| 报告名称变长，UI 显示不全 | 前端截断显示，tooltip 显示完整名称 |
| 同一案例报告过多，难以查找 | 优化排序和筛选功能，支持按时间范围过滤 |
| 随机数冲突（极低概率） | 使用足够长的随机数（6 位十六进制）；创建前检查唯一性 |

## Migration Plan

### 部署步骤
1. 部署新的 `report_service.py` 代码
2. 重启后端服务
3. 验证新报告生成正常

### 回滚策略
- 回滚到旧版本 `report_service.py`
- 新生成的报告可能继续覆盖，但不影响已有数据
- 无需数据库回滚

### 数据迁移
- 无需数据迁移
- 旧报告保持不变
- 新报告使用新命名规则

## Open Questions

1. 是否需要在 UI 中显示报告的运行序号？
   - 当前设计：不显示，使用创建时间排序
   - 未来可扩展：添加运行次数统计

2. 是否需要限制单个案例/计划的最大报告数量？
   - 当前设计：不限制
   - 未来可扩展：添加配置项限制
